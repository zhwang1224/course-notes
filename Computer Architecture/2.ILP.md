## 3.1 指令级并行
1. 由于指令可以并行执行，所以指令之间的可能的重叠执行称为指令级并行 ILP
ILP大体有两种实现方法：
   1. 依靠硬件来动态发现并实现并行
   2. 依靠软件技术在编译时发现并行

2. 流水线CPI每条指令占用的周期数 = 理想流水线CPI+结构化停顿+数据冒险停顿+控制停顿
   1. 理想流水线CPI是最佳性能
   2. 最小化CPI

3. 提高ILP最简单的方法就是在一个循环的歌词迭代之间利用并行，循环级并行
4. 数据依赖和冒险
   1. 数据依赖 真数据依赖 如果是数据依赖必须顺序执行，不能同时也不能完全重叠，这种依赖意味着两条指令存在一个或多个数据冒险构成的链
   2. 名称依赖和控制依赖  使用相同的寄存器或地址；分支控制
   3. 数据冒险hazard：
      1. RAW 写后读
      2. WAW 写后写
      3. WAR 读后写
      4. RAR 读后读不是冒险
顺序执行和乱序执行
5. Loop:fld 	f0,0(x1)    //f0=array element
		fadd.d 	f4,f0,f2	//add scalar in f2
		fsd 	f4,0(x1) 	//store result
		addi 	x1,x1,8 	//decrement pointer
								//8 bytes (per DW)
		bne 	x1,x2,Loop	//branch x1 != x2 

## 3.2 ILP的基本编译器技术
1. 基本流水线调度和循环展开
   1. 循环的简单流水线不执行调度执行的情况有很多停顿和空闲时钟周期，可以进行调度缩短一个循环执行的周期，但依旧利用率不高，增加指令数量的一个有效方法是循环展开 Loop unrolling, 就是将循环复制多次，同时调整循环的终止代码。
   2. 对展开循环调度所获得的收益比源循环进行调度要大，但大量展开和调度会导致寄存器紧缺。
      1. 循环展开，复制四份代码，省掉了三次分支转移和对x1的递减。展开后进行调度减少停顿。
2. 相关分支预测器
   1. 利用其他分支行为来进行预测的分支预测器为相关预测器
   2. 竞争预测器：全局局部预测器
   3. 利用先进的分支预测降低分支开销

## 用动态调度来克服数据冒险
1. 动态调度
   1. 硬件重新安排指令执行顺序，减少停顿同时保持数据令
   2. 允许针对一种流水线的代码在不同流水线上高效执行，不需要重新进行编译
   3. 可以应对依赖关系未知的情况
   4. 可以允许处理器容忍一些意料之外的延迟
2. 动态调度思想
   1. 使指令在数据准备好后立刻执行，意味着乱序执行、乱序完成，这会带来WAR WAW的危险。动态调度就会带来不精确中断，使异常的现场恢复很麻烦。为了实现乱序执行，ID阶段被拆成两个部分——Issue（译码，检查数据危险）Read Operands（等到没有数据危险读数）
   2. 我们区分指令何时开始执行和何时完成执行;在这之间，指令正在执行。流水线允许多个指令同时执行，需要多个功能单元，所有指令依次通过发布阶段(有序发布);然而，它们可能在第二阶段(读取操作数)停滞或相互绕过，从而进入无序执行。
   3. 记分牌SCORE boarding：资源充足、不存在数据依赖时乱序执行指令
   4. Tomasulo算法：算法同规格动态重命名来处理反依赖和输出依赖，此外还可以进行扩展处理预测
3. 记分牌 SCORE BOARDING
   1. 传统顺序执行会造成严重的阻塞，解决需要乱序执行，那么就需要多配置流水，为各种指令做个性化的配置，这样就可以乱序执行。
   2. 记分牌算法CDC乱序执行算法，包括两个FP mult,一个浮点除，一个浮点加法，和一个整数模块，Scoreboard就是记分牌，其实就是信息处理单元。
      1. 记分牌第一部分存储这五个部件的信息，包括是否正在忙，部件执行的指令，目的寄存器，部件现在需要的寄存器，如果源寄存器没准备好部件该向哪里要数据（Qj、Qk 表示），源寄存器是否准备好。
      2. 第二部分记录寄存器结果状态，记录正准备写入数据的部件。
      3. 具体工作流程：发射 取数 执行 写回
      4. 优缺点及特点
         1. 顺序发射和乱序执行
         2. 优点在于实现了指令的乱序执行，解决了乱序执行过程中的数据冒险问题。
         3. 但记分牌算法还是会因为WAR WAW 冒险而产生阻塞，一旦产生阻塞，后续相同类型的指令就没办法发射
         4. 而且不按顺序写回，不按顺序完成指令会对程序的调试提出挑战。
         5. 没有硬件转发forwarding
         6. small window
         7. small number of functional units
4. Branch-Prediction Buffer BPB 分支预测缓冲器
   1. 通过历史信息{Address,value},通过分支预测器，进行预测，得到目标地址和值。
   2. 分支预测在遇到分支指令的时候不等待分支结果而是直接在取指阶段预测跳不跳以及跳转地址，目的是根据预测结果来实现不间断的指令流，从而降低CPI，token是分支的意思。
   3. 静态预测只有两种，跳或者不跳。一位两位饱和计数器，其中00、01表示不跳转，10、11表示跳转。00表示强不跳转。
5. Tomasulo算法
   1. 记分牌
      1. SocreBoard采用停滞发射、tag广播和停滞写回机制解决了三种数据冒险，从而在逻辑上支持了乱序执行。
      2. 每一个运算部件都只拥有一个OPRAND流水段寄存器，这意味着多配置处理器中的每一条配置通路同一时间只能存在一条指令
   2. 数据冒险
      1. 读后写和写后写 RAW WAW 都可以通过寄存器重命名解决，而写后读WAR冒险无法通过重命名解决。写后写”和“读后写”冒险不是真冒险，没必要为他们阻塞指令的流动。
   3. Tomasulo加入了加法和乘法单元的保留站，保留已经发送的指令的信息和缓冲下来的数据。而Tomasulo算法则为每一条通路配置了一组缓冲，而保留站则直接把能读取的数据直接拷贝到保留站中。
   4. 记分牌和保留站相同的地方是都记录了Qj和Qk，即一旦需要的数据被算出来，就通过Qj和Qk捕捉广播数据，这样的做法其实就是重命名，即用保留站的编号而不是寄存器编号来标记数据源。
   5. Tomasulo算法的调度分为三个步骤：发射、执行、写回。相比记分牌少了读数这个环节，因为在Tomasulo中指令在发射时就会读数，Tomasulo算法是顺序发射的，即指令按照程序中的顺序一条接一条被发射到保留站。判断能否发射的唯一标准是指令对应通路的保留站是否有空余位置。
   6. 优点
      1. 而Tomasulo引入保留站之后每条通路可以缓冲下多条指令，这样的做法平缓了指令发射的速度
      2. 寄存器名字不重要，寄存器里的数据才重要
   7. 缺点
      1. 执行单元同时只能执行一条指令，所以就需要从中选择一条指令，简单的解决办法是为保留站的每一行增加一个年龄位，每次出现冲突，就选择最老的指令送到执行单元。
      2. 最后还有最为重要的一点，Tomasulo算法没办法实现精确中断。要支持精确中断，就要确保指令按序提交。重排序缓冲的概念，利用这一概念，可以改进Tomasulo算法，从而实现处理器的按序发射-乱序执行-按序提交。
   
6. 重排序 Reorder buffer ROB
   1. 而Tomasulo一文指出乱序提交正是Tomasulo最大的缺点。这是因为冯诺依曼结构向程序员承诺了处理器会按照程序的顺序来执行指令
   2. 因为控制指令、程序异常和外部中断也会截断指令流，所以通过顺序提交指令来实现精确中断（这里的中断是指中断指令流）至关重要。
   3. 优缺点
      1. 让保留站变得更加灵活
      2. 实现顺序提交，支持分支预测
      3. 增加硬件资源，在基于ROB的Tomasulo算法中，一个逻辑寄存器的结果被拷贝到太多地方。
   4. 在需要精确中断和分支预测的现代处理器中，ROB是一个基石性质的概念，每一个高性能处理器核都要有ROB。