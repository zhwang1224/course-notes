# 超越经典搜索

## 4.1 局部搜索和最优化
1. 经典搜索：完全客观察、确定、静态、已知、离散，系统地探索从初始状态到目标状态， 解是一个行动序列。
2. 松弛问题：放款限制条件，不关注到达目标的路径，主要关注最终状态。
3. 局部搜索（local search）：
   1. 算法：从当前节点出发，通常只移动到它的临近状态。
   2. 优点：
      1. 大幅减少计算和存储开销
      2. 在经典搜索不适用的很大的无限的连续空间状态中找到合理的解
4. 最优化问题：通过目标函数找到最佳状态。
5. 目标函数和启发式函数：目标函数通常用于优化问题，启发式函数通常用于搜索和决策问题。

### 4.1.1 爬山法
1. 基本思想：不断向目标函数值增加的方向持续移动。
   1. 总是向相邻状态移动
   2. 不维护搜索树
   3. 到达顶峰时，邻接状态没有更高的状态   
2. 算法流程：
   1. 每一步当前节点都会被它的最佳邻接结点所替代
   2. 最佳邻接结点意味着VALUE值最大
   3. 可以使用启发式代价评估函数h 目标函数
3. 爬山法的困境在于
   1. 局部最优
   2. 山脊方向干扰
   3. 高原迷失方向 全局信息缺失导致短视
   4. 所以并不完备
4. 改进思路
   1. 侧向移动：继续前进
   2. 随机爬山：随机生成后继节点
   3. 首选爬山：随机生成后继直至出现一个更优
   4. 随机重启爬山：随机选择初始，直至成功

### 4.1.2 模拟退火搜索 Simulated anealing
1. 纯粹的随机游走算法
   1. 随机从后继集合中选择扩展，完备但是效率极低
   2. 爬山法贪婪但不完备
2. 模拟退火的思想
   1. 模拟退火也是贪婪算法
   2. 搜索过程引入了随机
   3. 以一定概率接受一个比当前还要差的状态，可能跳出局部最优，达到全局最优
3. 算法步骤
![1](/course-notes/人工智能/image/第二部分/1.jpg)

### 4.1.3 局部束搜索 local beam search
1. 局部搜索的特点：不记录路径
2. 局部束搜索：
   1. 算法思想：宽度优先，记录k个状态而不只是记录一个，集束大小参数k
   2. k个状态是随机生成，然后选择k个最优后继，并行搜索
   3. 进一步改进：随机束搜索，随机选择k个后继
   4. 重启爬山是串行搜索，局部束是并行。

### 4.1.4 遗传算法 Genetic Algorithm
1. 遗传算法是随机束搜索的一个变种
   1. 对后继选择上不是完全随机的
   2. 通过两个父状态结合来生成后继
   3. 引入随机又不完全随机
2. GA算法思想
   1. 种群k个随机状态，个体某个随机状态
   2. 编码--用一个有限字符串表示个体，染色体
   3. 适应度函数--计算个体适应度的函数，可以是目标函数
   4. 选择：根据个体适应度从一个种群中选择适应性好的进入下一代
   5. 交叉：重组过程随机选择杂交
   6. 变异：突变
3. 对GA算法的思考
   1. 优势在于杂交
   2. 随机杂交不一定带来优势
   
局部搜索遗传算法、蚁群贝叶斯、蒙特卡洛树搜索、粒子群都是解决三个核心问题：
1. 局部最优
2. 山脊 方向偏移
3. 高原 方向迷失
4. 从后继节点的选择中引入随机或者扩大搜索范围

## 4.2 连续空间的局部搜索
1. 基本思想：连续问题**离散化**
2. 新建机场问题
   1. 新建三个机场，每个城市到最近机场的距离平方和最小。
   2. 解决方案：连续空间离散化
      1. 将坐标按x方向或y方向正负移动一个固定的量
      2. 六个变量，每个状态有12个后继邻接
   3. 解决方案2: 直接应用随机爬山或模拟退火
      1. 随机生长长度为n的向量
      2. 随机选择后继
   4. 解决方案3: 利用梯度最优化求解直接获得极值
3. 连续状态空间的局部搜索同样收到局部最大值、山脊高原的影响

## 4.3 不确定动作的搜索
之前对环境的假设-完全可观察、确定的
1. Agent 总知道自己处于什么状态
2. Agent 准确知道某个行动序列后达到什么状态
3. 行动开始后，无需提供新的信息

### 4.3.1 不稳定的吸尘器世界
3. 不确定动作的形式化
   1. 推广转移模型 Result函数
   2. 推广解的概念
   3. 一棵树而非路径

### 4.3.2 与或搜索树
1. 或节点 可选择的选项
   1. 在确定环境下，分支是由agent在每个状态下的选择形成的
2. 与节点 选择选项的可能结果
   1. 再不确定环境下，分支形成的可能是由于环境选择每个行动的后果
3. 解的形态
   1. 一颗子树
   2. 每个叶子都有目标
   3. 或节点规范一个活动
   4. 与节点包含所有可能
4. 搜索与执行交错
5. loop的 处理
   1. 当前状态与某条路径上的状态相同
   2. 遇到loop则返回失败

### 4.3.3 不断尝试
移动动作可能失败需要循环，不断尝试

## 4.4 部分可观察信息的搜索
1. 部分可观察
   1. agent未来行动依赖于感知信息（可能为0）
   2. 感知不足以精确描述状态
2. 信念状态 belief state
   1. 在给定行动序列和感知信息的情况下表达agent对它当前所在的物理世界的信念。
3. 信念状态空间！= 实际状态空间
4. 状态空间变了，搜索基本框架不变

### 4.4.1 无观察信息的搜索
1. 无传感问题   
   1. 信念状态空间中的问题是完全可观察的
2. 无传感信息的形式化
   1. 信念状态：整个信念状态空间包含的物理状态的每个可能集合{1，2，3，4，5}
   2. 初始状态：问题p中的所有状态的集合
   3. 行动：假设非法行动对环境没有影响，所有物理状态的动作的并集
   4. 转移模型：在信念状态下的某一物理状态采用某个行动可能导致另一状态
      1. 确定性动作和不确定性动作，不确定的动作会导致信念状态变大
      2. **预测-行动后生成新的信念状态的过程**
   5. 目标测试：信念状态满足目标当且仅当所有物理状态都满足目标测试
   6. 路径开销可能会有多个值
3. 无传感信息搜索的解
   1. 增量式求解

### 4.4.2 有观察信息的搜索
1. PERCEPT(s)函数
   1. 完全可观察PERCEPT(s)=s
   2. 无感知PERCEPT(s)=null
   3. 部分可观察PERCEPT(s)=[A, dirty]
2. 完成某个动作的三个阶段 RESULT(b,a)
   1. 预测阶段
   2. 观察预测阶段
   3. 更新阶段

### 4.4.3 求解部分可观察环境中的问题
   1. 使用与或搜索树，解是一个条件规划
   2. [suck, right, if state=6 then suck else []]

### 4.4.4 部分可观察环境中的Agent
   1. NSW NS 障碍物

## 4.5 联机搜索和未知环境
   1. 脱机搜索：先对实际行动计算完整解决方案之后在行动
   2. 联机搜索：交替计算和行动来完成任务

### 4.5.1 联机搜索
   1. 环境假设：确定的、完全可观察的
   2. Agent已知信息：
      1. Actions(s) 状态s下可能进行的行动列表
      2. 单步耗散函数c（s,a,s'）
      3. Goal-test(s)
   3. 注意这里没有result(s,a)函数（转移模型）
   4. 竞争比：实际开销/最短路径
   5. 死胡同：无法到达目标的状态；活动不可逆
   
### 4.5.2 联机搜索Agent
1. 联机搜索agent每次行动之后都能接收到感知信息
   1. 已到达状态
   2. 根据信息扩展地图
2. 无法引入随机重启，可以随机行走
3. 存储访问状态